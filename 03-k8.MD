k8 service 
==========
pod to pod coomunication, IP address is not useful since it is ephemeral . we have services in kubernetes to acieve
1.pod to pod communication
2.load balancing 

 -> create a cluster
 -> cd k8-resources
 -> kubectl get nodes
 -> kubectl apply -f 12-service.yaml
 -> kubectl get pods
 -> kubectl get services
    -> kubectl describe svc nginx

-> kubectl get pods -o wide
-> ls
-> kubectl apply -f 04-labels.yaml
-> kubectl get pods  // label pod is running
so we need to connect the labels pod with nginx pod
 to hit the nginx through nginx service

-----------------------------------------------------------------------------

1. 12-service.yaml

-> kubectl exec -it labels --bash
    -> curl http://nginx:80
    -> kubectl get svc //service
    -> kubectl describe svc nginx

-> kubectl apply -f 12-service.yaml
-> kubectl describe svc nginx     // we can see endpoints
-> kubectl ecex -it labels -- bash
  -> curl http://nginx:80
    // you will get the http response
    // here DNS will work on the service name

-> kubectl get svc
  in the service you  will have
  clusterIP  // bydefault it will have   // it is a internal service inside the cluster
  nodeport   // it is the external 
  LoadBalancer //it the extrnal means in the broswer what we can see

---------------------------------------------------------------------------------  

2. serive-nodeport.yaml
    -> kubectl apply -f 13-service-nodeport.yaml
    -> kubectl get svc
        u will see a port with 32732
        open it with <IP adress-32732>
        it will not open in browse bcz
        // change the inbound rules in the security group of that ip to port range-32732 / 0.0.0.0
        // now the sever will open
        // NodePort and cluster ip NP is the subset of cluster ip
        // we had 3 ec2 insatnces if anyone hit  on any ip that NODEPORT (port-32732)  will open in that ip address 
        // we need to just allow the secuirity group  thats it
        //NODEPORT will open all the port in all the ips so if if we hit any IP address it will hit that CLUSTER IP so that load balancer (nginx pod) will activate it will equally distrubute


-------------------------------------------------------------------------------------

3. 14-service-loadbalancer.yaml
    -> kubectl apply -f 14-service-loadbalancer.yaml
    -> kubectl get svc
    // LB will have NP and clusterIP the real LB is created
    //using the DNS and open it in the browser it will open nginx server
    // user is hitting on port no 80 it will hit on the NP so the LB is activated and all the worknodes will be activate under LB 
    -> chck the security group 
    -> check LB security group

    -> user port 80 - LB - nodesports  - nginx-lb-service - nginx-nodeport


--------------------------------------------------------------------------------------------

clusterIP - internal to the cluster
nodePort - it will open port called nodeport in every node
LoadBalancer - it will create a loadbalancer and nodeport in all the nodes

loadbalancer --> node on nodeport ---> ClusterIP -->  pod (it can be in any pod)  th traffic will come from that pod to the nginxNP

ClusterIP --> only internal services, means will in the cluster . .




------------------------------------------------------

How to create the multiple pods in the same image ? 

kubectl apply -f 04-labels.yaml
kubectl get pods
kubectl delete -f 12-service.yaml  13-service-nodeport.yaml  14-services-loadbalancer.yaml
kubectl delete -f 12-service.yaml
kubectl delete -f 13-service-nodeport.yaml
kubectl delete -f 14-service-loadbalancer.yaml

------------------------------------------------

4. 15-replicaset.yaml

    -> kubectl apply -f 15-replicaset.yaml
    -> kubect get pods

    // purpose is if anything deletes or crash than at any cost it should run 3 replicas bcz we have given it and it will create
    // if you del <nginx-w22cw> it wiill again 2 sec it will create another replica
    // if you want 10 it will creatre 10


-------------------------------------------------

Deployment

 a version change is there
 v1, code changes --> v2
 1.delete v1 application
 2.download v2 application
 3.restart

 nginx v1 -> nginx v2 
 so image will change nginx:v2

 del old pods --. and create new pods new image


 5. 16-deployment.yaml
    -> kubectl apply -f 16-deployment.yaml
    -> kubectl get pods
    -> kubectl get rs  //replicaset

pod is a subset of replicaset and replicaset is a subset of deployment

deployment is subset of --> is a subset of  replicaset --> is a subset of pod --> container

in the image if you change a image to other version so the Deployment will create a another Replicaset and another newpods and old pods will get deleted automatically